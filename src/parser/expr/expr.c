#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

#include "debug.h"
#include "expr.h"

#include "../lexer/helpers.h"
#include "../lexer/lexer.h"
#include "../../prelude.h"

#define WORKING_BUF_SZ 128
#define QUEUE_BUF_SZ 256
#define OPERATOR_BUF_SZ 64
#define END_PRECEDENCE 127

// int construct_fn_call(char *line, Token tokens[], Expr *expr, int last_expr, int ntokens, int *depth, int *consumed)
// {
//     int end_func_flag = 0;
//     size_t single_expr_idx = 0;
//     char *name = malloc(tokens[0].end - tokens[0].start);

//     expr->inner.uni.interal_data.fncall.func_name = name;
//     memcpy(name, line + tokens[0].start, tokens[0].end - tokens[0].start);

//     if (tokens[2].token != PARAM_CLOSE)
//     {
//         expr->inner.uni.interal_data.fncall.args = malloc(sizeof(struct Expr *) * 8);
//         expr->inner.uni.interal_data.fncall.args_capacity = 7;

//         last_expr = 2;
//         while (ntokens > last_expr)
//         {
//             single_expr_idx = 0;

//             if (end_func_flag)
//                 break;

//             for (size_t i = last_expr; ntokens > i; i++)
//             {
//                 if (end_func_flag)
//                     break;
                
//                 // if comma or param_close
//                 if (tokens[i].token == COMMA)
//                 {
//                     single_expr_idx = i;
//                     break;
//                 }

//                 else if (tokens[i].token == PARAM_CLOSE)
//                 {
//                     end_func_flag = 1;
//                     break;
//                 }
//             }

//             struct Expr *item = malloc(sizeof(struct Expr));
//             expr->inner.uni.interal_data.fncall.args[expr->inner.uni.interal_data.fncall.args_length] = item;

//             if (construct_expr_inner(line, tokens + last_expr, single_expr_idx, item) == -1)
//             {
//                 return -1;
//             }

//             // TODO
//             // check for overflow
//             expr->inner.uni.interal_data.fncall.args_length += 1;
//             last_expr = single_expr_idx + 1;
//         }
//     }
//     expr->inner.uni.op = UniCall;
//     expr->type = UniExprT;
// }

enum Associativity {
    NONASSOC,
    RASSOC,
    LASSOC
};

enum Associativity get_assoc(int8_t precedence) {
    if (END_PRECEDENCE > precedence > 4)
        return RASSOC;
    else if(5 > precedence > 1)
        return LASSOC;
    
    return NONASSOC;
}

/*
    precendense table:
      ") ] }"   : 127 non-assoc
      "." "::"  : 6 R Object Application
      "^"       : 5 Right-assoc (2 ^ 2 ^ 2) -> (2 ^ (2 ^ 2))
      "/ * %"   : 4 Left-assoc  (4 / 2 * 2) -> ((4 / 2) * 2)
      "+ -"     : 3 L
      "!= == >= > <= < && ||": 2 L
      ","       : 1
      "( [ {"   : 0 non-assoc
*/
int8_t op_precedence(enum Lexicon token) {
    if (token == PARAM_CLOSE 
        || token == BRACE_CLOSE 
        || token == BRACKET_CLOSE)
        return END_PRECEDENCE;
    
    if (token == DOT)
        return 6;
    
    else if (token == POW)
        return 5;

    else if (token == MUL 
        || token == DIV
        || token == MOD)
        return 4;

    else if (token == ADD || token == SUB)
        return 3;
    
    else if (token == ISEQL
        || token == ISNEQL
        || token == GTEQ
        || token == LTEQ
        || token == GT
        || token == LT
        || token == AND
        || token == OR)
        return 1;
    
    else if (token == PARAM_OPEN 
        || token == BRACE_OPEN  
        || token == BRACKET_OPEN )
        return 0;
    
    return -1;
}

/*
    creates a duplicate version of `input[]`, 
    but replaces sequences of tokens which represent a function call
    (`[WORD] [PARAM_OPEN] ... [PARAM_CLOSE]`) into a single token with
    the type defined as `FNMASK`.

    The duplicated input, with their respective `FNMASK` tokens will be 
    placed into `*output[]` as pointers in the order they were received.

    FNMASK tokens will act as a temporary compound token.
    FNMASK is not generated by the lexer,
    instead its used here once for order precedence.
            
    Function calls will have no special ordering, 
    they will be treated as normal operands, executing
    in the order they occured with their 
    respected operators precedence.

    When constructing and using FNMASK tokens, its data fields
    `start` will correlate to the index of `input[]` where it originates from.
    `end` will correlate to the index of `input[]` where it originates from.
*/
int create_fnmasks(
    struct Token *output[],
    usize output_sz,
    usize *output_ctr,

    struct Token input[],
    usize expr_size,

    struct Token masks[],
    usize masks_sz,
    usize *masks_ctr,
    struct CompileTimeError *err
){
    uint8_t making_mask = 0;

    usize parathesis_ctr = 0,
        starts_at = 0,
        span = 0;
    
    *output_ctr = 0;
    *masks_ctr = 0;
    
    for (usize i=0; expr_size > i; i++)
    {        
        if (making_mask && input[i].type == PARAM_OPEN) {
            span += 1;
            parathesis_ctr += 1;
        }

        else if (making_mask && input[i].type == PARAM_CLOSE) {
            span += 1;
            parathesis_ctr -= 1;
            
            if(parathesis_ctr == 0)
            {
                // we've successfully minted a new FNMASK token
                *masks_ctr += 1;
                *output_ctr += 1;

                if (*masks_ctr >= masks_sz || *output_ctr >= output_sz)
                    return -1;
                
                masks[(*masks_ctr)-1].start = starts_at;
                masks[(*masks_ctr)-1].end = starts_at+span;
                masks[(*masks_ctr)-1].type = FNMASK; 

                output[(*output_ctr)-1] = &masks[(*masks_ctr)-1];
                starts_at=0;
                making_mask=0;
                span=0;
            }
        }

        else if (input[i].type == WORD
            && input[i+1].type == PARAM_OPEN
            && parathesis_ctr == 0){
            starts_at=i;
            making_mask=1;
        }

        else if (making_mask==0 && parathesis_ctr == 0 && starts_at == 0) {
            *output_ctr += 1;
            output[(*output_ctr)-1] = &input[i];
        }
        else {
            span += 1;
            continue;
        }
    }
    /* loop ended before token could be stored */
    if (starts_at || making_mask || span) {
        *masks_ctr += 1;
        *output_ctr += 1;

        if (*masks_ctr >= masks_sz || *output_ctr >= output_sz)
            /* buffer overflow */
            return -1;
            
        masks[(*masks_ctr)-1].start = starts_at;
        masks[(*masks_ctr)-1].end = starts_at+span;
        masks[(*masks_ctr)-1].type = FNMASK; 
        output[(*output_ctr)-1] = &masks[(*masks_ctr)-1];
    }

    return 0;
}


/*
    Eval masks are a similar concept to the FNMASK, except consider the following.
    `"foo().length" will not parse `[FNMASK, DOT, WORD]`
    They will contain both all of the following tokens.

                  "foo().length"
    FNMASK         ----^
    COMPOSITE      -----------^
*/


/*
  Shunting yard expression parsing algorthim 
  https://en.wikipedia.org/wiki/Shunting-yard_algorithm
  --------------
  takes a token stream, and two extra buffers, and converts an infix expression
  into a postfix expression.

  *tokens[]
    token stream - expects the token stream `*output[]` from `
  
  *queue[]
    references tokens inside of `tokens[]`,
    but annotated in postfix (reverse polish notation)

  *mask[]
    `*queue[]` may also refer to tokens inside this buffer.
    This temporary buffer contains FNMASK tokens, 
    this converts function calls into a single token for
    ordering precendence
*/
int8_t construct_postfix_queue(
    struct Token *tokens[],
    usize expr_size,
    struct Token *queue[],
    usize queue_sz,
    usize *queue_ctr
){
    struct Token *hdlr = NULL;

    *queue_ctr = 0;

    struct Token *operators[64];
    usize operators_ctr = 0;
    
    struct Token *working_buf[32];
    usize working_buf_ctr = 0;

    int8_t precedense = 0;
    /*
        NOTE:
            When ordering precedense, our algorithmn expects a single token,
            but a function call is a collection of tokens.
            To compensate, we'll create a token with FNMASK 
            as its identifier.
    */

    for (usize i = 0; expr_size > i; i++)
    {
        if (is_data(tokens[i]->type) 
            || tokens[i]->type == FNMASK
            || tokens[i]->type == NOT)
        {
            if (*queue_ctr >= queue_sz)
                return -1;
            
            *queue_ctr += 1;
            queue[(*queue_ctr) - 1] = &tokens[i];
            continue;
        }
        
        /*
            every other operation is left-to-right accoicated
            except for the night operator
        */

        else if (is_bin_operator(tokens[i]->type))
        {
            /*
                since this is a operator, 
                we need to set precedense for their operands.
            */
            precedense = op_precedence(tokens[i]->type);

            /* unrecongized token */
            if (precedense == -1)
                return -1;

            else if (precedense == 0 || operators_ctr == 0) {
                operators_ctr += 1;
                operators[operators_ctr - 1] = &tokens[i];
                continue;
            }
            else
            {
                /*
                NOTE:
                    Compare our current token's precedense 
                    (order of evaluation),
                    to the last operator's precedense. 
                    If our current precedense is higher, then
                    pop operators off the stack until the previous
                    operationis equal/less than our current precedense,
                    OR the LAST precedense is 0. afterwards
                    we insert our current token into operators stack. 
                    finally, we push all of the operators we popped off 
                    in reverse order.
                */
                // this section smells funny
                for (usize j = 0; operators_ctr > j; j++)
                {
                    if (operators[operators_ctr - 1]->type != invert_brace_type(tokens[i]->type))
                    {
                        if (*queue_ctr >= queue_sz)
                            return -1;
                        
                        *queue_ctr += 1;
                        queue[(*queue_ctr) - 1] = operators[operators_ctr - 1];
                        operators_ctr -= 1;
                    } else {
                        operators_ctr -= 1;
                        break;
                    }

                    working_buf_ctr += 1;
                    working_buf[working_buf_ctr - 1] = operators[operators_ctr - 1];
                    
                    if (operators_ctr == 0 || op_precedence(working_buf[working_buf_ctr - 1]->type) == 0)
                    {
                        operators_ctr -= 1;
                        break;
                    }
                    else
                        operators_ctr -= 1;
                }
            }
        }

        else {}
    }

    /*
    NOTE:
        dump the remaining operators onto the queue
    */
    usize temp = operators_ctr;
    for (usize k = 0; temp > k; k++)
    {
        /*any remaining params/brackets/braces are unclosed if reached here*/
        if (op_precedence(operators[operators_ctr - 1]) == END_PRECEDENCE)
            return -1;
        
        *queue_ctr += 1;
        queue[*queue_ctr - 1] = operators[operators_ctr - 1];
        operators_ctr -= 1;
    }
    return 0;
}


int8_t construct_expr_ast(char *line, struct Token tokens[], usize ntokens, struct Expr *expr) {
    // struct Token *masked_tokens[512];
    // struct Token *queue[512];
    // struct Token masks[32];
    // struct Token *working_buf[128];
    // size_t masks_ctr = 0;
    // size_t masked_tokens_ctr = 0;
    // size_t queue_ctr = 0;

    // if (!is_balanced(tokens, ntokens))
    //     return -1;
    
    // if (create_fnmasks(
    //     masked_tokens, 512, &masked_tokens_ctr,
    //     tokens, ntokens,
    //     masks, 32, &masks_ctr) == -1)
    //     return -1;
    

    // if (tokens[0].type == NOT) {}
    // else if (is_fncall(tokens)) {}
    // else if (is_data(tokens[0].type)) {}
    // else if (tokens[0].type == DOT) {}

    // if (create_fnmasks(
    //     masked_tokens, 512, &masked_tokens_ctr,
    //     tokens, ntokens,
    //     masks, 32, &masks_ctr) == -1)
    //     return -1;
    
    // /*
    //     reorders `*output[]` according to PEMDAS
    //     into the buffer `*queue[]`
    // */
    // if (construct_postfix_queue(masked_tokens, masked_tokens_ctr, queue, 512, &queue_ctr) == -1)
    //     return -1;
    
    // for (int i=0; queue_ctr > i; i++) {
    //     else if (is_data(queue[i])) {}
    //     if (is_bin_operator(queue[i]) {}
    // }

    /*todo: create expr tree*/
}
