#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

#include "debug.h"
#include "expr.h"

#include "../../prelude.h"


// int construct_fn_call(char *line, Token tokens[], Expr *expr, int last_expr, int ntokens, int *depth, int *consumed)
// {
//     int end_func_flag = 0;
//     size_t single_expr_idx = 0;
//     char *name = malloc(tokens[0].end - tokens[0].start);

//     expr->inner.uni.interal_data.fncall.func_name = name;
//     memcpy(name, line + tokens[0].start, tokens[0].end - tokens[0].start);

//     if (tokens[2].token != PARAM_CLOSE)
//     {
//         expr->inner.uni.interal_data.fncall.args = malloc(sizeof(struct Expr *) * 8);
//         expr->inner.uni.interal_data.fncall.args_capacity = 7;

//         last_expr = 2;
//         while (ntokens > last_expr)
//         {
//             single_expr_idx = 0;

//             if (end_func_flag)
//                 break;

//             for (size_t i = last_expr; ntokens > i; i++)
//             {
//                 if (end_func_flag)
//                     break;
                
//                 // if comma or param_close
//                 if (tokens[i].token == COMMA)
//                 {
//                     single_expr_idx = i;
//                     break;
//                 }

//                 else if (tokens[i].token == PARAM_CLOSE)
//                 {
//                     end_func_flag = 1;
//                     break;
//                 }
//             }

//             struct Expr *item = malloc(sizeof(struct Expr));
//             expr->inner.uni.interal_data.fncall.args[expr->inner.uni.interal_data.fncall.args_length] = item;

//             if (construct_expr_inner(line, tokens + last_expr, single_expr_idx, item) == -1)
//             {
//                 return -1;
//             }

//             // TODO
//             // check for overflow
//             expr->inner.uni.interal_data.fncall.args_length += 1;
//             last_expr = single_expr_idx + 1;
//         }
//     }
//     expr->inner.uni.op = UniCall;
//     expr->type = UniExprT;
// }

/*
    precendense table:
      ") ] }"   : 5
      "/ * ^ %" : 3
      "+ -"     : 2
      "!= == >= > <= < && ||": 1
      "( [ {"   : 0
*/
int op_precedence(enum Lexicon token) {
    if (token == PARAM_CLOSE 
        || token == BRACE_CLOSE 
        || token == BRACKET_CLOSE)
        return 5;
   
    else if (token == MUL 
        || token == DIV
        || token == MOD
        || token == POW)
        return 3;

    else if (token == ADD || token == SUB)
        return 2;
    
    else if (token == ISEQL
        || token == ISNEQL
        || token == GTEQ
        || token == LTEQ
        || token == GT
        || token == LT
        || token == AND
        || token == OR)
        return 1;
    
    else if (token == PARAM_OPEN 
        || token == BRACE_OPEN  
        || token == BRACKET_OPEN )
        return 0;
    
    return -1;
}

/*
push on the top of the stack
*/
int push_stack_lifo(struct Token *stack[], struct Token *token, size_t *ctr, size_t stack_sz) {
    if (*ctr >= stack_sz)
        return -1;

    *ctr+=1;
    stack[*ctr-1] = token;
    return 0;
}

/*
pop off the top of the stack
*/
const struct Token* pop_stack_lifo(
    struct Token *stack[],
    struct Token *token,
    size_t *ctr,
    size_t stack_sz
) {
    struct Token *hdlr;

    if (*ctr >= stack_sz && *ctr >= 1)
        return NULL;
    
    hdlr = stack[*ctr-1];
    *ctr -= 1;

    return hdlr;
}

int is_closing_brace(enum Lexicon token) {
    return (token == PARAM_CLOSE 
    || token == BRACE_CLOSE  
    || token == BRACKET_CLOSE);
}

/*
    this function creates a duplicate version of `input[]`, 
    but replaces sequences of tokens which represent a function call
    (`[WORD] [PARAM_OPEN] ... [PARAM_CLOSE]`) into a single token with
    the type defined as `FNMASK`.

    The duplicated input, with their respective `FNMASK` tokens will be 
    placed into `*output[]` as pointers in the order they were received.

    FNMASK tokens will act as a temporary compound token.
    FNMASK is not generated by the lexer,
    instead its used here once for order precedence.
            
    Function calls will have no special ordering, 
    they will be treated as normal operands, executing
    in the order they occured with their 
    respected operators precedence.

    When constructing and using FNMASK tokens, its data fields
    `start` will correlate to the index of `input[]` where it originates from.
    `end` will correlate to the index of `input[]` where it originates from.
*/
int create_fnmasks(
    struct Token *output[],
    size_t output_sz,
    size_t *output_ctr,
    struct Token input[],
    size_t expr_size,
    struct Token masks[],
    size_t masks_sz,
    size_t *masks_ctr
){
    short unsigned int making_mask = 0;
    size_t parathesis_ctr = 0;
    size_t starts_at = 0;
    size_t span = 0;
    *output_ctr = 0;
    *masks_ctr = 0;
    
    for (size_t i=0; expr_size > i; i++)
    {        
        if (making_mask && input[i].token == PARAM_OPEN) {
            span += 1;
            parathesis_ctr += 1;
        }

        else if (making_mask && input[i].token == PARAM_CLOSE) {
            span += 1;
            parathesis_ctr -= 1;
            
            if(parathesis_ctr == 0)
            {
                // we've successfully minted a new FNMASK token
                *masks_ctr += 1;
                *output_ctr += 1;

                if (*masks_ctr >= masks_sz || *output_ctr >= output_sz)
                    return -1;
                
                masks[(*masks_ctr)-1].start = starts_at;
                masks[(*masks_ctr)-1].end = starts_at+span;
                masks[(*masks_ctr)-1].token = FNMASK; 

                output[(*output_ctr)-1] = &masks[(*masks_ctr)-1];
                starts_at=0;
                making_mask=0;
                span=0;
            }
        }

        else if (input[i].token == WORD
            && input[i+1].token == PARAM_OPEN
            && parathesis_ctr == 0){
            starts_at=i;
            making_mask=1;
        }

        else if (making_mask==0 && parathesis_ctr == 0 && starts_at == 0) {
            *output_ctr += 1;
            output[(*output_ctr)-1] = &input[i];
        }
        else {
            span += 1;
            continue;
        }
    }
    /* loop ended before token could be stored */
    if (starts_at || making_mask || span) {
        *masks_ctr += 1;
        *output_ctr += 1;

        if (*masks_ctr >= masks_sz || *output_ctr >= output_sz)
            return -1;
            
        masks[(*masks_ctr)-1].start = starts_at;
        masks[(*masks_ctr)-1].end = starts_at+span;
        masks[(*masks_ctr)-1].token = FNMASK; 
        output[(*output_ctr)-1] = &masks[(*masks_ctr)-1];
    }

    return 0;
}


/*
  Shunting yard expression parsing algorthim 
  https://en.wikipedia.org/wiki/Shunting-yard_algorithm
  --------------
  takes a token stream, and two extra buffers, and converts an infix expression
  into a postfix expression.

  tokens*[]
    token stream - expects the token stream `*output[]` from `
  
  *queue[]
    references tokens inside of `tokens[]`, but sorted for postfix

  *mask[]
    `*queue[]` may also refer to tokens inside this buffer.
    This temporary buffer contains FNMASK tokens, 
    this converts function calls into a single token for
    ordering precendence
*/
int construct_postfix_queue(
    struct Token *tokens[],
    size_t expr_size,
    struct Token *queue[],
    size_t queue_sz,
    size_t *queue_ctr
){
    struct Token *hdlr = NULL;

    *queue_ctr = 0;

    struct Token *operators[64];
    int operators_ctr = 0;
    
    struct Token *working_buf[32];
    int working_buf_ctr = 0;

    int precedense = 0;
    /*
        NOTE:
            When ordering precedense, our algorithmn expects a single token,
            but a function call is a collection of tokens.
            To compensate, we'll create a token with FNMASK 
            as its identifier.
    */

    for (size_t i = 0; expr_size > i; i++)
    {
        if (is_data(tokens[i]->token) || tokens[i]->token == FNMASK)
        {
            if (*queue_ctr >= queue_sz)
                return -1;
            
            *queue_ctr += 1;
            queue[(*queue_ctr) - 1] = &tokens[i];
            continue;
        }

        else if (is_bin_operator(tokens[i]->token))
        {
            /*
                since this is a operator, 
                we need to set precedense for their operands.
            */
            precedense = op_precedence(tokens[i]->token);

            /* unrecongized token */
            if (precedense == -1)
                return -1;

            else if (precedense == 0 || operators_ctr == 0) {
                operators_ctr += 1;
                operators[operators_ctr - 1] = &tokens[i];
                continue;
            }
            else
            {
                /*
                NOTE:
                    Compare our current token's precedense 
                    (order of evaluation),
                    to the last operator's precedense. 
                    If our current precedense is higher, then
                    pop operators off the stack until the previous
                    operationis equal/less than our current precedense,
                    OR the LAST precedense is 0. afterwards
                    we insert our current token into operators stack. 
                    finally, we push all of the operators we popped off 
                    in reverse order.
                */
                for (int j = 0; operators_ctr > j; j++)
                {
                    if (operators[operators_ctr - 1]->token != invert_brace_type(tokens[i]->token))
                    {
                        if (*queue_ctr >= queue_sz)
                            return -1;
                        
                        *queue_ctr += 1;
                        queue[(*queue_ctr) - 1] = operators[operators_ctr - 1];
                        operators_ctr -= 1;
                    } else {
                        operators_ctr -= 1;
                        break;
                    }
                    working_buf_ctr += 1;
                    working_buf[working_buf_ctr - 1] = operators[operators_ctr - 1];
                    
                    if (operators_ctr == 0 || op_precedence(working_buf[working_buf_ctr - 1]->token) == 0)
                    {
                        operators_ctr -= 1;
                        break;
                    }
                    else
                        operators_ctr -= 1;
                }
            }
        }
    }
    

    /*
    NOTE:
        dump the remaining operators onto the queue
    */
    size_t temp = (size_t)operators_ctr;
    for (size_t k = 0; temp > k; k++)
    {
        /*any remaining params/brackets/braces are unclosed if reached here*/
        if (op_precedence(operators[operators_ctr - 1]) == 5)
            return -1;
        
        *queue_ctr += 1;
        queue[*queue_ctr - 1] = operators[operators_ctr - 1];
        operators_ctr -= 1;
    }
    return 0;
}

int construct_expr(char *line, struct Token tokens[], unsigned long  ntokens, struct Expr *expr) {
    struct Token *output[512];
    struct Token *queue[512];
    struct Token masks[32];
    size_t masks_ctr = 0;
    size_t output_ctr = 0;
    size_t queue_ctr = 0;

    /*
        duplicate `tokens` into `*output[]`
        and creates compound tokens
        for function calls    
    */
    if (create_fnmasks(
        output, 512, &output_ctr,
        tokens, ntokens,
        masks, 32, &masks_ctr) == -1)
        return -1;
    
    /*
        reorders `*output[]` according to PEMDAS
        into the buffer `*queue[]`
    */
    if (construct_postfix_queue(output, output_ctr, queue, 512, &queue_ctr) == -1)
        return -1;

    /*todo: create expr tree*/
}
