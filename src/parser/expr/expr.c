#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <time.h>

#include "../../prelude.h"
#include "../lexer/lexer.h"
#include "../lexer/helpers.h"

#include "expr.h"


#define WORKING_BUF_SZ 128
#define QUEUE_BUF_SZ 256
#define OPERATOR_BUF_SZ 64
#define END_PRECEDENCE 127

// int construct_fn_call(char *line, Token tokens[], Expr *expr, int last_expr, int ntokens, int *depth, int *consumed)
// {
//     int end_func_flag = 0;
//     size_t single_expr_idx = 0;
//     char *name = malloc(tokens[0].end - tokens[0].start);

//     expr->inner.uni.interal_data.fncall.func_name = name;
//     memcpy(name, line + tokens[0].start, tokens[0].end - tokens[0].start);

//     if (tokens[2].token != PARAM_CLOSE)
//     {
//         expr->inner.uni.interal_data.fncall.args = malloc(sizeof(struct Expr *) * 8);
//         expr->inner.uni.interal_data.fncall.args_capacity = 7;

//         last_expr = 2;
//         while (ntokens > last_expr)
//         {
//             single_expr_idx = 0;

//             if (end_func_flag)
//                 break;

//             for (size_t i = last_expr; ntokens > i; i++)
//             {
//                 if (end_func_flag)
//                     break;
                
//                 // if comma or param_close
//                 if (tokens[i].token == COMMA)
//                 {
//                     single_expr_idx = i;
//                     break;
//                 }

//                 else if (tokens[i].token == PARAM_CLOSE)
//                 {
//                     end_func_flag = 1;
//                     break;
//                 }
//             }

//             struct Expr *item = malloc(sizeof(struct Expr));
//             expr->inner.uni.interal_data.fncall.args[expr->inner.uni.interal_data.fncall.args_length] = item;

//             if (construct_expr_inner(line, tokens + last_expr, single_expr_idx, item) == -1)
//             {
//                 return -1;
//             }

//             // TODO
//             // check for overflow
//             expr->inner.uni.interal_data.fncall.args_length += 1;
//             last_expr = single_expr_idx + 1;
//         }
//     }
//     expr->inner.uni.op = UniCall;
//     expr->type = UniExprT;
// }

enum Associativity {
    NONASSOC,
    RASSOC,
    LASSOC
};

enum Associativity get_assoc(enum Lexicon token) {
    switch(token) {
        case POW:
            return RASSOC;
        default:
            return LASSOC;
    }
}

/*
    precendense table:
      ") ] }"   : 127 non-assoc
      "."     : 126 L
      
    
      "^"       : 6 R (1 ^ 2 ^ 3) -> (1 ^ (2 ^ 3))
      "/ * %"   : 5 L  (4 / 2 * 2) -> ((4 / 2) * 2)
      "+ -"     : 4 L
      "!= == >= > <= < && ||": 3 L
      "!"       : 2 L
      "( [ {"   : 0 non-assoc
*/
int8_t op_precedence(enum Lexicon token) {
    if (is_close_brace(token))
        return END_PRECEDENCE;
    
    if (token == DOT)
        return 126;
    
    else if (token == POW)
        return 6;

    else if (token == MUL 
        || token == DIV
        || token == MOD)
        return 5;

    else if (token == ADD
        || token == SUB)
        return 4;
    
    else if (token == ISEQL
        || token == ISNEQL
        || token == GTEQ
        || token == LTEQ
        || token == GT
        || token == LT
        || token == AND
        || token == OR)
        return 2;
    
    else if (is_open_brace(token))
        return 0;
    
    return -1;
}
/*
    creates a duplicate version of `input[]`, 
    but replaces sequences of tokens which represent a function call
    (`[WORD] [PARAM_OPEN] ... [PARAM_CLOSE]`) into a single token with
    the type defined as `FNMASK`.

    The duplicated input, with their respective `FNMASK` tokens will be 
    placed into `*output[]` as pointers in the order they were received.

    FNMASK tokens will act as a temporary compound token.
    FNMASK is not generated by the lexer,
    instead its used here once for order precedence.
            
    Function calls will have no special ordering, 
    they will be treated as normal operands, executing
    in the order they occured with their 
    respected operators precedence.

    When constructing and using FNMASK tokens, its data fields
    `start` will correlate to the index of `input[]` where it originates from.
    `end` will correlate to the index of `input[]` where it originates from.
*/

/* Replicate `*src`, but replace slices of tokens with `FNMASK` tokens */
int8_t create_token_stream(
    struct Token *output[],
    usize output_sz,
    usize *output_ctr,
    
    struct Token input[],
    usize ninput,

    struct Token masks[],
    usize nmasks
) {
    usize masks_ctr = 0;

    for (usize i=0; ninput > i; i++) {
        if (masks[masks_ctr].start == i) {
            
            output[*output_ctr] = &masks[masks_ctr];
            
            i += masks[masks_ctr].end - masks[masks_ctr].start;
            
            masks_ctr += 1;
            *output_ctr += 1;
        }
        
        output[*output_ctr] = &input[i]; 
        *output_ctr += 1;

        if (*output_ctr > output_sz)
            return -1; 
    }

    return 0;
}

/*
    This is the first stage of parsing function calls.

    During this stage, we will create new 
    tokens based off of our current token stream.
    These new tokens will be of the type FNMASK.

    FNMASK tokens attributes `start` and `end` 
    are directly indexible against their source.

    The `start` attribute will point at the WORD 
    token starting the function. example: `foo();` 
    the attribute `start` will point at `"foo"` token.

    The `en` attribute will point at the PARAM_CLOSE 
    token end the function. example: `foo();` 
    the attribute `end` will point at `")"` token.

    The creation of FNMASK tokens should not mutate its source (`input`).
    
    the amount of FNMASKS created will be placed inside
    of `masks_ctr`
    
    `mask_ctr` will be initalized to 0 before  its used 
    internally in this function.

    Function returns 0 for OK and -1 for error.
*/
int8_t mk_fnmask_tokens(
    struct Token input[],
    usize expr_size,

    struct Token masks[],
    usize masks_sz,
    usize *masks_ctr,
    struct CompileTimeError *err
){
    uint8_t making_mask = 0;

    usize parathesis_ctr = 0,
        starts_at = 0,
        span = 0;
    
    *masks_ctr = 0;
    
    for (usize i=0; expr_size > i; i++)
    {        
        if (making_mask && input[i].type == PARAM_OPEN) {
            span += 1;
            parathesis_ctr += 1;
        }

        else if (making_mask && input[i].type == PARAM_CLOSE) {
            span += 1;
            parathesis_ctr -= 1;
            
            if(parathesis_ctr == 0)
            {
                // we've successfully minted a new FNMASK token

                if ((*masks_ctr)+1 >= masks_sz)
                    return -1;
                
                masks[*masks_ctr].start = starts_at;
                masks[*masks_ctr].end = starts_at+span;
                masks[*masks_ctr].type = FNMASK; 

                *masks_ctr += 1;

                starts_at=0;
                making_mask=0;
                span=0;
            }
        }

        else if (input[i].type == WORD
            && input[i+1].type == PARAM_OPEN
            && parathesis_ctr == 0)
        {
            starts_at=i;
            making_mask=1;
        }
        else if (making_mask)
        {
            span += 1;
            continue;
        }
    }

    /* loop ended before token could be stored */
    if (starts_at || making_mask || span) {
        
        if ((*masks_ctr)+1 >= masks_sz)
            /* buffer overflow */
            return -1;
            
        masks[*masks_ctr].start = starts_at;
        masks[*masks_ctr].end = starts_at+span;
        masks[*masks_ctr].type = FNMASK; 
    }

    return 0;
}

int8_t fncall_get_argc(
    uint8_t *param_ctr,
    struct Token *target_mask,
    struct Token src[],
    struct CompileTimeError *err
){
    struct Token masks[32];
    usize masks_len=0,
          masks_ctr=0;
    
    if (target_mask->type != FNMASK)
        return -1;
    
    else if (target_mask->start+1 == target_mask->end
        && src[target_mask->start+1].type == PARAM_CLOSE)
        return 0;
    
    else if (mk_fnmask_tokens(
        &src[target_mask->start],
        target_mask->end - target_mask->start,
        masks,
        32,
        &masks_len,
        err) == -1
    ) return -1;

    for (usize i=target_mask->start+1; target_mask->end+1 > i; i++) {
        /* skip ahead of functions */
        if (masks[masks_ctr].start == i && masks_len > masks_ctr){
            i += masks[masks_ctr].end - masks[masks_ctr].start;
            masks_ctr += 1;
        }

        else if (src[i].type == COMMA)
            *param_ctr += 1;

        if (*param_ctr > 255)
            return -1;
    }

    return 0;
}

int8_t fnmask(
    struct Token input[],
    struct Token *parent_mask,
    struct FnCall output[],
    usize *output_ctr,
    struct CompileTimeError *err
){
    struct Token masks[32];
    
    usize masks_len=0,
          masks_ctr=0,
          comma_ctr=0,
          i;
    
    if (parent_mask->type != FNMASK)
        return -1;
    
    /* If function's parameters is empty, return 0*/
    else if (parent_mask->start+1 == parent_mask->end
        && input[parent_mask->start+1].type == PARAM_CLOSE)
    {
        output[*output_ctr].argc = 0;
        memcpy(
            &output[*output_ctr].token,
            parent_mask,
            sizeof(struct Token)
        );
        *output_ctr += 1;
        return 0;
    }
    
    /* generate makes and fill in masks array */
    else if (mk_fnmask_tokens(
        &input[parent_mask->start],
        parent_mask->end - parent_mask->start,
        masks,
        32,
        &masks_len,
        err) == -1
    ) return -1;

    for (i=parent_mask->start+1; parent_mask->end+1 > i; i++) {
        if (masks_ctr > masks_len) break;
        
        /* skip ahead of functions */
        else if (masks[masks_ctr].start == i && masks_len > masks_ctr){
            i += masks[masks_ctr].end - masks[masks_ctr].start;
            masks_ctr += 1;
        }

        else if (input[i].type == COMMA)
            comma_ctr += 1;
    }
    
    if (comma_ctr == 0)
        output[*output_ctr].argc = 1;
    else
        output[*output_ctr].argc = comma_ctr + 1;
    
    memcpy(
        &output[*output_ctr].token,
        parent_mask,
        sizeof(struct Token)
    );
    
    *output_ctr += 1;

    for (i=0; masks_len > i; i++) {
        fnmask(input, &masks[i], output, output_ctr, err);
    }

    return 0;
}

int8_t mk_fncalls(
    struct FnCall output[],
    struct Token input[],
    usize ninput,
    struct CompileTimeError *err    
) {

    struct Token masks[256];
    usize masks_ctr = 0;

    mk_fnmask_tokens(
        input,
        ninput,
        masks,
    
        256,
        &masks_ctr,
        err
    );

    
    return 0;
}


/*
    composite masks are a similar concept to the FNMASK, except consider the following.
    `"foo().length" will not parse `[FNMASK, DOT, WORD]`
    They will contain both all of the following tokens.

                  "foo().length"
    FNMASK         ^---^
    COMPOSITE      ^----------^
    

int8_t mk_composite_tokens(
    struct Token *tokens[],
    usize ntokens,
    struct Token *output[],
    usize *output_ctr,
    usize output_sz,
    struct Token composite_tokens[],

    usize composite_tokens_sz,
    usize *composite_tokens_ctr
) {
    strussct Token composite_token;
    usize span=0;
    usize starts_at=0;
    uint8_t is_collecting_tokens = 0;

    *composite_tokens_ctr = 0;
    *output_ctr = 0;
    
    for (usize i=0; ntokens > i; i++) {
        if (tokens[i]->type == FNMASK 
            || tokens[i]->type == WORD 
            || tokens[i]->type == DOT)
        {
            if(is_collecting_tokens)
                span += 1;
            else {
                is_collecting_tokens=1;
                starts_at=i;
            }
        }

        else if (is_collecting_tokens) {
            composite_token.type = COMPOSITE;
            composite_token.start = starts_at;
            composite_token.end = starts_at + span;
            
            is_collecting_tokens = 0;
            starts_at = 0;
            span = 0;

            if (*output_ctr > output_sz || *composite_tokens_ctr > composite_tokens_sz)
                // bounds check
                return -1;
            
            composite_tokens[*composite_tokens_ctr] = composite_token;
            output[*output_ctr] = &composite_tokens[*composite_tokens_ctr];

            *output_ctr += 1;
            *composite_tokens_ctr += 1;
        }

        else if (!is_collecting_tokens) {
            // bounds check
            if(*output_ctr > output_sz)
                return -1;
            
            output[*output_ctr] = tokens[i];
            *output_ctr += 1;
        }
    }
    return 0;
}
*/

/*
  Shunting yard expression parsing algorthim 
  https://en.wikipedia.org/wiki/Shunting-yard_algorithm
  --------------
  takes a token stream, and two extra buffers, and converts an infix expression
  into a postfix expression.

  NOTE:
    When ordering precedense, our algorithmn expects a single token,
    but a function call is a collection of tokens.
    To compensate, we'll create a token with FNMASK 
    as its identifier.
  
  *tokens[]
    WARNING: Expects stream to have been processed 
            to contain FNMASK tokens

  *queue[]
    references tokens inside of `tokens[]`,
    but annotated in postfix (reverse polish notation)

  *mask[]
    `*queue[]` may also refer to tokens inside this buffer.
    This temporary buffer contains FNMASK tokens, 
    this converts function calls into a single token for
    ordering precendence

*/


#define STACK_SZ 128
#define _OP_SZ 128


int8_t postfix_expr(
    struct Token *tokens[],
    usize expr_size,
    
    struct Token *output[],
    usize output_sz,
    usize *output_ctr,
    
    struct Token grouping_tokens[],
    uint8_t grouping_tokens_sz,
    uint8_t *grouping_tokens_ctr,

    struct Token *functions[],
    uint8_t functions_sz,
    uint8_t *functions_ctr,

    struct CompileTimeError *err
){
    /* operator stack */
    struct Token *operators[STACK_SZ];

    /*
        operators stack pointer, always points 
        to the next available index
    */
    int8_t operators_ctr = 0;
  
    /* head of the operator stack*/
    struct Token *head = NULL;
    
    /* head of the operator stacks precedence*/
    int8_t head_precedense = 0;

    /* current tokens precedence */
    int8_t precedense = 0;

    /*
        keep track of the amount of sequal expressions
        eg foo(1, 2, 3) [1, 2, 3] {1, 2, 3}
        each statement has 3 sub-expressions.
        we use this stack to track the number of sub-expressions
        per grouping.
    */

    uint8_t grouping_stack[STACK_SZ];
    uint8_t grouping_ctr = 0;

    uint8_t expecting_operand = 1;
    uint8_t expecting_operator = 0;

    for (usize i = 0; expr_size > i; i++)
    {
        /*
            if the token is data (value/variable in the source code),
            place it directly into our stack
        */
        if (is_data(tokens[i]->type))
        {
            if (!expecting_operand)
                return -1;

            /*
                Our current token is a function name.
            */
            if (tokens[i]->type == WORD 
                && tokens[i+1]->type == PARAM_OPEN)
            {
                expecting_operand = 1;
                expecting_operator = 0;

                if (*functions_ctr > functions_sz)
                    return -1;
                
                /* book keeping to remember functions */
                functions[*functions_ctr] = tokens[i];
                functions_ctr += 1;

                if (operators_ctr > (int8_t)_OP_SZ)
                    return -1;
                
                /* place into operator stack */
                operators[operators_ctr] = tokens[i];
                operators_ctr += 1;
            }
            else
            /* if not a function, place it into output */
            {
                expecting_operand = 0;
                expecting_operator = 1;
                
                if (*output_ctr >= output_sz)
                    return -1;
                
                output[*output_ctr] = tokens[i];
                *output_ctr += 1;
            }
            continue;
        }

        /*
            
        */
        else if (tokens[i]->type == COMMA) {
            if (grouping_ctr > STACK_SZ)
                return -1;
            
            grouping_stack[grouping_ctr] += 1;
            expecting_operand = 1;
            expecting_operator = 0;
        }

        else if (is_bin_operator(tokens[i]->type))
        {
            if (!expecting_operator)
                return -1;
            
            expecting_operator = 0;
            expecting_operand = 1;
            
            precedense = op_precedence(tokens[i]->type);

            /* unrecongized token */
            if (precedense == -1)
                return -1;

            /*
                no operators in operators-stack, 
                so no extra checks needed
            */
            else if (operators_ctr == 0) { 
                operators[0] = tokens[i];
                operators_ctr += 1;
                continue;
            }

            /* Grab the head of the operators-stack */
            head = operators[operators_ctr-1];

            /*
                if the head of the operator stack is an open brace
                we don't need to do anymore checks
                before placing the operator
            */
            if (is_open_brace(head->type)) {
                if (operators_ctr > (int8_t)_OP_SZ)
                    return -1;
                
                operators[operators_ctr] = tokens[i];
                operators_ctr += 1;
                continue;
            }
            
            /*
                while `head` has higher precedence 
                than our current token pop operators from
                the operator-stack into the output
            */
            while(op_precedence(head->type) >= precedense && operators_ctr > 0)
            {
                head_precedense = op_precedence(head->type);

                if (is_open_brace(head->type))
                    break;
                
                /*
                    pop operators off the stack
                    into the output
                */
                if (head_precedense > precedense)
                {
                    if (*output_ctr > output_sz)
                        return -1;
                    
                    output[*output_ctr] = head;
                    *output_ctr += 1;
                }

                /* 
                    If left associated, push equal
                    precedence operators onto the output 
                */
                else if (precedense == head_precedense)
                {
                    if (get_assoc(tokens[i]->type) == LASSOC)
                    {
                        if (*output_ctr > output_sz)
                            return -1;
                        output[*output_ctr] = head;
                        *output_ctr += 1;
                    }
                }

                /* discard operator after placed in output */
                operators_ctr -= 1;
                if (operators_ctr <= 0)
                    break;
                
                head = operators[operators_ctr-1];
            }

            operators[operators_ctr] = tokens[i];
            operators_ctr += 1;
        }

        else if (is_close_brace(tokens[i]->type))
        {
            /* Operators stack is empty */
            if (operators_ctr == 0)
                return -1;
            
            /* Last operator in the operator-stack was the inverted brace */
            else if (operators[operators_ctr - 1]->type == invert_brace_tok_ty(tokens[i]->type))
                continue;
            
            /* should be atleast one operator in the stack */
            else if (operators_ctr <= 0)
                return -1;

            /* pop operators off of the operator-stack into the output */
            while(operators_ctr > 0) {
                /* Grab the head of the stack */
                head = operators[operators_ctr-1];

                /* ends if tokens inverted brace is found*/
                if (head->type == invert_brace_tok_ty(tokens[i]->type)) {
                    
                    /* discard opening brace */
                    operators_ctr -= 1;
                    break;
                }
                /* otherwise pop into output */
                else {    
                    if (*output_ctr > output_sz)
                        return -1;
                     
                    output[*output_ctr] = head;
                    *output_ctr += 1;
                    operators_ctr -= 1;                
                }
            }

            /* 
                the top of the stack is a function,
                push it onto the output, and discard
                from the operator stack
            */
            
            /*

            */
            if (grouping_stack[grouping_ctr] > 0) {

                if (grouping_ctr > STACK_SZ)
                    return -1;
                
                grouping_tokens[grouping_ctr].type = GROUPING;
                grouping_tokens[grouping_ctr].start = 0;
                grouping_tokens[grouping_ctr].end = grouping_stack[grouping_ctr] + 1;
                
                if (*output_ctr > output_sz)
                    return -1;
                
                output[*output_ctr] = &grouping_tokens[grouping_ctr];
                *output_ctr += 1;
            }
            grouping_ctr -= 1;
            
            /*
                if the last operator on the stack is a function,
                push the function into the output
            */
            if(operators_ctr > 0 && operators[operators_ctr-1]->type == WORD) {
                
                if (*output_ctr > output_sz)
                    return -1;
                
                output[*output_ctr] = head;
                *output_ctr += 1;
                operators_ctr -= 1;
            }

        }
        /*
            place opening brace on the operator stack,
            inside the 
        */
        else if (is_open_brace(tokens[i]->type))
        {
            if (grouping_ctr > STACK_SZ)
                return -1;

            grouping_ctr += 1;
            grouping_stack[grouping_ctr] = 0;

            if (operators_ctr > (int8_t)_OP_SZ)
                return -1;
            
            operators[operators_ctr] = tokens[i];
            operators_ctr += 1;
        }
        else
        {
            #ifdef DEBUG 
                printf("debug: token fell through precedense [%s]\n", ptoken(tokens[i]->type));
            #endif
        }
    }

    /*
        dump the remaining operators onto the output
    */
    while(operators_ctr > 0)
    {
        /*
            any remaining params/brackets/braces are unclosed
            indiciate invalid expressions    
        */
        if (is_open_brace(operators[operators_ctr-1]->type) == END_PRECEDENCE)
            return -1;
        
        if (*output_ctr > output_sz)
            return -1;
        
        output[*output_ctr] = operators[operators_ctr-1];
        
        *output_ctr += 1;
        operators_ctr -= 1;
    }

    return 0;
}


int8_t construct_expr_ast(char *line, struct Token tokens[], usize ntokens, struct Expr *expr) {
    // struct Token *masked_tokens[512];
    // struct Token *queue[512];
    // struct Token masks[32];
    // struct Token *working_buf[128];
    // size_t masks_ctr = 0;
    // size_t masked_tokens_ctr = 0;
    // size_t queue_ctr = 0;

    // if (!is_balanced(tokens, ntokens))
    //     return -1;
    
    // if (mk_fnmask_tokens(
    //     masked_tokens, 512, &masked_tokens_ctr,
    //     tokens, ntokens,
    //     masks, 32, &masks_ctr) == -1)
    //     return -1;
    

    // if (tokens[0].type == NOT) {}
    // else if (is_fncall(tokens)) {}
    // else if (is_data(tokens[0].type)) {}
    // else if (tokens[0].type == DOT) {}

    // if (mk_fnmask_tokens(
    //     masked_tokens, 512, &masked_tokens_ctr,
    //     tokens, ntokens,
    //     masks, 32, &masks_ctr) == -1)
    //     return -1;
    
    // /*
    //     reorders `*output[]` according to PEMDAS
    //     into the buffer `*queue[]`
    // */
    // if (construct_postfix_queue(masked_tokens, masked_tokens_ctr, queue, 512, &queue_ctr) == -1)
    //     return -1;
    
    // for (int i=0; queue_ctr > i; i++) {
    //     else if (is_data(queue[i])) {}
    //     if (is_bin_operator(queue[i]) {}
    // }

    /*todo: create expr tree*/
    return 0;
}
