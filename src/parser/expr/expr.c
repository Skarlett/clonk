#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

#include "../../prelude.h"
#include "../lexer/lexer.h"
#include "../lexer/helpers.h"

#include "expr.h"


#define WORKING_BUF_SZ 128
#define QUEUE_BUF_SZ 256
#define OPERATOR_BUF_SZ 64
#define END_PRECEDENCE 127

// int construct_fn_call(char *line, Token tokens[], Expr *expr, int last_expr, int ntokens, int *depth, int *consumed)
// {
//     int end_func_flag = 0;
//     size_t single_expr_idx = 0;
//     char *name = malloc(tokens[0].end - tokens[0].start);

//     expr->inner.uni.interal_data.fncall.func_name = name;
//     memcpy(name, line + tokens[0].start, tokens[0].end - tokens[0].start);

//     if (tokens[2].token != PARAM_CLOSE)
//     {
//         expr->inner.uni.interal_data.fncall.args = malloc(sizeof(struct Expr *) * 8);
//         expr->inner.uni.interal_data.fncall.args_capacity = 7;

//         last_expr = 2;
//         while (ntokens > last_expr)
//         {
//             single_expr_idx = 0;

//             if (end_func_flag)
//                 break;

//             for (size_t i = last_expr; ntokens > i; i++)
//             {
//                 if (end_func_flag)
//                     break;
                
//                 // if comma or param_close
//                 if (tokens[i].token == COMMA)
//                 {
//                     single_expr_idx = i;
//                     break;
//                 }

//                 else if (tokens[i].token == PARAM_CLOSE)
//                 {
//                     end_func_flag = 1;
//                     break;
//                 }
//             }

//             struct Expr *item = malloc(sizeof(struct Expr));
//             expr->inner.uni.interal_data.fncall.args[expr->inner.uni.interal_data.fncall.args_length] = item;

//             if (construct_expr_inner(line, tokens + last_expr, single_expr_idx, item) == -1)
//             {
//                 return -1;
//             }

//             // TODO
//             // check for overflow
//             expr->inner.uni.interal_data.fncall.args_length += 1;
//             last_expr = single_expr_idx + 1;
//         }
//     }
//     expr->inner.uni.op = UniCall;
//     expr->type = UniExprT;
// }

enum Associativity {
    NONASSOC,
    RASSOC,
    LASSOC
};

enum Associativity get_assoc(enum Lexicon token) {
    switch(token) {
        case POW:
            return RASSOC;
        default:
            return LASSOC;
    }
}

/*
    precendense table:
      ") ] }"   : 127 non-assoc
      "^"       : 6 R (1 ^ 2 ^ 3) -> (1 ^ (2 ^ 3))
      "/ * %"   : 5 L  (4 / 2 * 2) -> ((4 / 2) * 2)
      "+ -"     : 4 L
      "!= == >= > <= < && ||": 3 L
      "!"       : 2 L
      ", ."     : 1 L
      "( [ {"   : 0 non-assoc
*/
int8_t op_precedence(enum Lexicon token) {
    if (is_close_brace(token))
        return END_PRECEDENCE;
    
    if (token == DOT || token == COMMA)
        return 1;
    
    else if (token == POW)
        return 6;

    else if (token == MUL 
        || token == DIV
        || token == MOD)
        return 5;

    else if (token == ADD
        || token == SUB)
        return 4;
    
    else if (token == ISEQL
        || token == ISNEQL
        || token == GTEQ
        || token == LTEQ
        || token == GT
        || token == LT
        || token == AND
        || token == OR)
        return 2;
    
    else if (is_open_brace(token))
        return 0;
    
    return -1;
}

/*
    creates a duplicate version of `input[]`, 
    but replaces sequences of tokens which represent a function call
    (`[WORD] [PARAM_OPEN] ... [PARAM_CLOSE]`) into a single token with
    the type defined as `FNMASK`.

    The duplicated input, with their respective `FNMASK` tokens will be 
    placed into `*output[]` as pointers in the order they were received.

    FNMASK tokens will act as a temporary compound token.
    FNMASK is not generated by the lexer,
    instead its used here once for order precedence.
            
    Function calls will have no special ordering, 
    they will be treated as normal operands, executing
    in the order they occured with their 
    respected operators precedence.

    When constructing and using FNMASK tokens, its data fields
    `start` will correlate to the index of `input[]` where it originates from.
    `end` will correlate to the index of `input[]` where it originates from.
*/
int mk_fnmask_tokens(
    struct Token *output[],
    usize output_sz,
    usize *output_ctr,

    struct Token input[],
    usize expr_size,

    struct Token masks[],
    usize masks_sz,
    usize *masks_ctr,
    struct CompileTimeError *err
){
    uint8_t making_mask = 0;

    usize parathesis_ctr = 0,
        starts_at = 0,
        span = 0;
    
    *output_ctr = 0;
    *masks_ctr = 0;
    
    for (usize i=0; expr_size > i; i++)
    {        
        if (making_mask && input[i].type == PARAM_OPEN) {
            span += 1;
            parathesis_ctr += 1;
        }

        else if (making_mask && input[i].type == PARAM_CLOSE) {
            span += 1;
            parathesis_ctr -= 1;
            
            if(parathesis_ctr == 0)
            {
                // we've successfully minted a new FNMASK token

                if ((*masks_ctr)+1 >= masks_sz || (*output_ctr)+1 >= output_sz)
                    return -1;
                
                masks[*masks_ctr].start = starts_at;
                masks[*masks_ctr].end = starts_at+span;
                masks[*masks_ctr].type = FNMASK; 

                output[*output_ctr] = &masks[*masks_ctr];

                *masks_ctr += 1;
                *output_ctr += 1;

                starts_at=0;
                making_mask=0;
                span=0;
            }
        }

        else if (input[i].type == WORD
            && input[i+1].type == PARAM_OPEN
            && parathesis_ctr == 0)
        {
            starts_at=i;
            making_mask=1;
        }
        else if (making_mask==0 && parathesis_ctr == 0 && starts_at == 0)
        {
            output[*output_ctr] = &input[i];
            *output_ctr += 1;
        }
        else
        {
            span += 1;
            continue;
        }
    }

    /* loop ended before token could be stored */
    if (starts_at || making_mask || span) {
        
        if ((*masks_ctr)+1 >= masks_sz || (*output_ctr)+1 >= output_sz)
            /* buffer overflow */
            return -1;
            
        masks[*masks_ctr].start = starts_at;
        masks[*masks_ctr].end = starts_at+span;
        masks[*masks_ctr].type = FNMASK; 
        output[*output_ctr] = &masks[*masks_ctr];

    }

    return 0;
}
/*
    composite masks are a similar concept to the FNMASK, except consider the following.
    `"foo().length" will not parse `[FNMASK, DOT, WORD]`
    They will contain both all of the following tokens.

                  "foo().length"
    FNMASK         ^---^
    COMPOSITE      ^----------^
    

int8_t mk_composite_tokens(
    struct Token *tokens[],
    usize ntokens,
    struct Token *output[],
    usize *output_ctr,
    usize output_sz,
    struct Token composite_tokens[],

    usize composite_tokens_sz,
    usize *composite_tokens_ctr
) {
    strussct Token composite_token;
    usize span=0;
    usize starts_at=0;
    uint8_t is_collecting_tokens = 0;

    *composite_tokens_ctr = 0;
    *output_ctr = 0;
    
    for (usize i=0; ntokens > i; i++) {
        if (tokens[i]->type == FNMASK 
            || tokens[i]->type == WORD 
            || tokens[i]->type == DOT)
        {
            if(is_collecting_tokens)
                span += 1;
            else {
                is_collecting_tokens=1;
                starts_at=i;
            }
        }

        else if (is_collecting_tokens) {
            composite_token.type = COMPOSITE;
            composite_token.start = starts_at;
            composite_token.end = starts_at + span;
            
            is_collecting_tokens = 0;
            starts_at = 0;
            span = 0;

            if (*output_ctr > output_sz || *composite_tokens_ctr > composite_tokens_sz)
                // bounds check
                return -1;
            
            composite_tokens[*composite_tokens_ctr] = composite_token;
            output[*output_ctr] = &composite_tokens[*composite_tokens_ctr];

            *output_ctr += 1;
            *composite_tokens_ctr += 1;
        }

        else if (!is_collecting_tokens) {
            // bounds check
            if(*output_ctr > output_sz)
                return -1;
            
            output[*output_ctr] = tokens[i];
            *output_ctr += 1;
        }
    }
    return 0;
}
*/

/*
  Shunting yard expression parsing algorthim 
  https://en.wikipedia.org/wiki/Shunting-yard_algorithm
  --------------
  takes a token stream, and two extra buffers, and converts an infix expression
  into a postfix expression.

  NOTE:
    When ordering precedense, our algorithmn expects a single token,
    but a function call is a collection of tokens.
    To compensate, we'll create a token with FNMASK 
    as its identifier.
  
  *tokens[]
    WARNING: Expects stream to have been processed 
            to contain FNMASK tokens

  *queue[]
    references tokens inside of `tokens[]`,
    but annotated in postfix (reverse polish notation)

  *mask[]
    `*queue[]` may also refer to tokens inside this buffer.
    This temporary buffer contains FNMASK tokens, 
    this converts function calls into a single token for
    ordering precendence


  1st) pop operators off of the operator-stack 
       until the popped operator's precedense is equal
       than our current operator
                
  2nd) Check right/left association on the operator
       If Right: based off the precedence of the current operator pop the remaining
       equally valued operators from the operator-stack
                   
       If Left: Do nothing.

  3rd) place current operator and restore 
       previous operators to the
       operator-stack as they were ordered
                
        If our current precedense is higher, then
        pop operators off the stack until the previous
        operations equal/less than our current precedense,
        OR the LAST precedense is 0. afterwards
        we insert our current token into operators stack. 
        finally, we push all of the operators we popped off 
        in **reverse** order.
*/

#define _OP_SZ 128
#define _WK_BUF_SZ 64

int8_t postfix_expr(
    struct Token *tokens[],
    usize expr_size,
    struct Token *output[],
    usize output_sz,
    usize *output_ctr,
    struct CompileTimeError *err
){
    struct Token *head = NULL;
    int8_t head_precedense = 0;

    struct Token *operators[_OP_SZ];
    int8_t operators_ctr = 0;
    int8_t precedense = 0;

    *output_ctr = 0;


    for (usize i = 0; expr_size > i; i++)
    {
        /* if the token is data (value/variable in the source code),
        // place it directly into our stack */
        if (is_data(tokens[i]->type) || tokens[i]->type == FNMASK)
        {
            if (*output_ctr >= output_sz)
                return -1;
            
            output[*output_ctr] = tokens[i];
            *output_ctr += 1;
            continue;
        }

        // else if(tokens[i]->type == FNMASK) {

        // }

        else if (is_bin_operator(tokens[i]->type))
        {
            precedense = op_precedence(tokens[i]->type);

            /* unrecongized token */
            if (precedense == -1)
                return -1;

            /*
                no operators in operators-stack, 
                so no extra checks needed
            */
            else if (operators_ctr == 0) { 
                operators[0] = tokens[i];
                operators_ctr += 1;
                continue;
            }

            /* Grab the head of the operators-stack */
            head = operators[operators_ctr-1];
            head_precedense = op_precedence(head->type);
            /*
                if the head of the operator stack is an open brace
                we don't need to do anymore checks
                before placing the operator
            */
            if (is_open_brace(head->type)) {
                operators[operators_ctr] = tokens[i];
                operators_ctr += 1;
                continue;
            }
            
            // head_precedense = o2
            // precedense = o1
            while(op_precedence(head->type) >= precedense && operators_ctr > 0)
            {
                if (is_open_brace(head->type))
                    break;
                
                if (head_precedense > precedense)
                {
                    output[*output_ctr] = head;
                    *output_ctr += 1;
                }

                /* test asscotation */
                else if (precedense == head_precedense)
                {
                    if (get_assoc(tokens[i]->type) == LASSOC)
                    {
                        output[*output_ctr] = head;
                        *output_ctr += 1;
                    }
                }
                
                operators_ctr -= 1;
                if (operators_ctr <= 0)
                    break;
                
                head = operators[operators_ctr-1];
            }

            operators[operators_ctr] = tokens[i];
            operators_ctr += 1;

            /*
                Place operator in the operator stack,
                and remove lower precedense operators from it,
                where they'll be placed into the output.
            */
        }
        else if (is_close_brace(tokens[i]->type))
        {
            /* Operators stack is empty */
            if (operators_ctr == 0)
                return -1;
            
            /* Last operator in the operator-stack was the inverted brace */
            else if (operators[operators_ctr - 1]->type == invert_brace_tok_ty(tokens[i]->type))
                continue;
            
            /* should be atleast one operator in the stack */
            if (operators_ctr <= 0)
                return -1;
            
            /* pop operators off of the operator-stack into the output */
            while(operators_ctr > 0) {
                /* Grab the head of the stack */
                head = operators[operators_ctr-1];

                /* ends if tokens inverted brace is found*/
                if (head->type == invert_brace_tok_ty(tokens[i]->type)) {
                    operators_ctr -= 1;
                    break;
                }
                /* otherwise pop into output */
                else {
                    output[*output_ctr] = head;
                    *output_ctr += 1;
                    operators_ctr -= 1;                
                }
            }
        }
        else if (is_open_brace(tokens[i]->type))
        {
            operators[operators_ctr] = tokens[i];
            operators_ctr += 1;
        }
        else
        {
        #ifdef DEBUG 
            printf("debug: token fell through precedense [%s]\n", ptoken(tokens[i]->type));
        #endif
        }
    }

    /*
        dump the remaining operators onto the output
    */
    while(operators_ctr > 0)
    {
        /*
            any remaining params/brackets/braces are unclosed
            indiciate invalid expressions    
        */
        if (is_open_brace(operators[operators_ctr-1]->type) == END_PRECEDENCE)
            return -1;
        
        output[*output_ctr] = operators[operators_ctr-1];
        
        *output_ctr += 1;
        operators_ctr -= 1;
    }

    return 0;
}


int8_t construct_expr_ast(char *line, struct Token tokens[], usize ntokens, struct Expr *expr) {
    // struct Token *masked_tokens[512];
    // struct Token *queue[512];
    // struct Token masks[32];
    // struct Token *working_buf[128];
    // size_t masks_ctr = 0;
    // size_t masked_tokens_ctr = 0;
    // size_t queue_ctr = 0;

    // if (!is_balanced(tokens, ntokens))
    //     return -1;
    
    // if (mk_fnmask_tokens(
    //     masked_tokens, 512, &masked_tokens_ctr,
    //     tokens, ntokens,
    //     masks, 32, &masks_ctr) == -1)
    //     return -1;
    

    // if (tokens[0].type == NOT) {}
    // else if (is_fncall(tokens)) {}
    // else if (is_data(tokens[0].type)) {}
    // else if (tokens[0].type == DOT) {}

    // if (mk_fnmask_tokens(
    //     masked_tokens, 512, &masked_tokens_ctr,
    //     tokens, ntokens,
    //     masks, 32, &masks_ctr) == -1)
    //     return -1;
    
    // /*
    //     reorders `*output[]` according to PEMDAS
    //     into the buffer `*queue[]`
    // */
    // if (construct_postfix_queue(masked_tokens, masked_tokens_ctr, queue, 512, &queue_ctr) == -1)
    //     return -1;
    
    // for (int i=0; queue_ctr > i; i++) {
    //     else if (is_data(queue[i])) {}
    //     if (is_bin_operator(queue[i]) {}
    // }

    /*todo: create expr tree*/
    return 0;
}
